import java.io.*;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Vector;

public class PropertyManager implements Serializable {
    private Vector<Property> properties = new Vector<>();
    private Vector<Rental> rentals = new Vector<>();

    public Vector<Property> getProperties() {
        return properties;
    }

    public void setProperties(Vector<Property> properties) {
        this.properties = properties;
    }

    public Vector<Rental> getRentals() {
        return rentals;
    }

    public void setRentals(Vector<Rental> rentals) {
        this.rentals = rentals;
    }

    public void addProperty(Property newProperty, Vector<Property> properties, int numbersSoFar){
        int pos = findPosition(newProperty.getPropertyID(), properties, numbersSoFar);
        shift(pos, properties, numbersSoFar);
        properties.set(pos, newProperty);
    }

    public void addRental(Rental rental){
        rentals.add(rental);
    }

    public void viewProperties(){
        for(Property property : properties){
            property.printDetailedInfo();
        }
    }

    public void viewRentals(){
        for(Rental rental : rentals){
            System.out.println(rental.getProperty());
            System.out.println(rental.getRentalStartDate());
            System.out.println(rental.getRentalEndDate());
            System.out.println();
        }
    }

    public boolean isPropertyIDValid(String propertyID){
        for(Property property : properties){
            if(property.getPropertyID().equals(propertyID)){
                System.out.println(propertyID + " is already being used. Please enter another ID");
                return false;
            }
        }
        if(propertyID.length() < 10){
            System.out.println(propertyID + " has less than 10 characters. Please enter another ID");
            return false;
        }
        return true;
    }

    public void removeProperty(String propertyID){
        for(int i = 0; i < properties.size(); i++){
            Property property = properties.get(i);
            if(property.getPropertyID().equals(propertyID)){
                properties.remove(i);
                return;
            }
        }
    }

    public boolean doesPropertyIDExist(String propertyID){
        for(Property property : properties){
            if(property.getPropertyID().equals(propertyID)){
                return true;
            }
        }
        return false;
    }

    public Property findPropertyByPropertyID(String propertyID){
        for(Property property : properties){
            if(property.getPropertyID().equals(propertyID)){
                return property;
            }
        }
        return null;
    }


    public void calculateTotalRents(){
        HashMap<String, Float> totalRents = new HashMap<>();

        for(Rental rental : rentals){
            Property property = rental.getProperty();
            //calculate number of months of the rental
            long monthsBetween = ChronoUnit.MONTHS.between(rental.getRentalStartDate().withDayOfMonth(1), rental.getRentalEndDate().withDayOfMonth(1));
            if(rental.getRentalEndDate().getDayOfMonth() > rental.getRentalStartDate().getDayOfMonth()){
                monthsBetween++; //adds a month in case a rental ends before the end of a particular month
            }
            float totalRentForThisRental = monthsBetween * property.getMonthlyRentalPrice();

            //allows for a final rent amount generated by each property
            totalRents.merge(property.getPropertyID(), totalRentForThisRental, Float::sum);
        }

        //print total rents collected for each property
        for(String propertyID : totalRents.keySet()){
            System.out.println("Property ID: " + propertyID + ", Total Rent Collected: â‚¬" + totalRents.get(propertyID));
        }
    }

    public void saveFile() throws IOException {
        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("propertyList.dat"));
        os.writeObject(properties);
        os.writeObject(rentals);
        os.close();
    }

    public void loadFile() throws IOException {
        ObjectInputStream is = new ObjectInputStream(new FileInputStream("propertyList.dat"));
        try{
            properties = (Vector<Property>) is.readObject();
            rentals = (Vector<Rental>) is.readObject();
        } catch(FileNotFoundException e){
            System.out.println("File does not exist");
        } catch(ClassNotFoundException e){
            System.out.println("A class in the serialized object cannot be found");
        }
        is.close();
    }

    private void shift(int pos, Vector<Property> properties, int numbersSoFar){
        properties.add(null); //adds element at end of Vector to have space for shift
        for(int i = numbersSoFar; i > pos; i--){
            properties.set(i, properties.get(i - 1));
        }
    }

    private int findPosition(String propertyID, Vector<Property> properties, int numbersSoFar){
        for(int i = 0; i < numbersSoFar; i++){
            if(propertyID.compareTo(properties.get(i).getPropertyID()) < 0){
                return i;
            }
        }
        return numbersSoFar;
    }
}
